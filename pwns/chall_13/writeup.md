- no win function
- no pie, and nx enabled
- will need to write shellcode
- or a ROP
- first we send our offest of junk and then
  - the PLT for puts
  - the vuln address
  - the GOT for puts

- also had to serach for a 32bit copy of libc (libc.so) with the following command
-  find / -name libc.so* 2>/dev/null
- and declared with this - libc = ELF('/usr/lib/i386-linux-gnu/libc.so.6')


- in essensce, this will 
  - 1. overwite the return addr (instruction pointer) with the puts PLT
  - 2. then execution returns to vuln
  - 3. before returning, it sets the the PLT entry of puts as the new GOT entry for puts
  - 4. so now when puts is called it calls puts from the dynamically linked libc library
  - 5. This is how we get our addr leak
  - 6. Then we can calculate the base address of libc by doing our leak - libc.sym.puts
  - 7. we now do the same method as before to overwrite the return address (instruction pointer) with our libc adddress
  - 8. get our padding with rule of ryan, put the libc (system) address
  - 9. then, we need to pad another 4 bytes to get to the first argument that system will find
  - 10. finally, we pass bin/sh into the system and it is called



